/**
 * Idle Clicker Game Library
 *
 * Eine modulare, erweiterbare Bibliothek für Idle/Clicker Games.
 * Verwaltet Spiellogik, Upgrades, Auto-Save und Idle-Progress.
 */

class IdleGame {
    /**
     * Erstellt eine neue Idle Game Instanz
     * @param {Object} config - Konfigurationsobjekt
     * @param {number} config.tickRate - Update-Rate in Millisekunden (default: 100ms)
     * @param {number} config.saveInterval - Auto-Save Intervall in Millisekunden (default: 5000ms)
     */
    constructor(config = {}) {
        // Basis-Konfiguration
        this.config = {
            tickRate: config.tickRate || 100,
            saveInterval: config.saveInterval || 5000,
            saveKey: config.saveKey || 'idleGameSave'
        };

        // Spielzustand
        this.state = {
            points: 0,
            totalClicks: 0,
            totalPointsEarned: 0,
            clickPower: 1,
            pointsPerSecond: 0,
            lastTick: Date.now(),
            startTime: Date.now()
        };

        // Upgrades-System
        this.upgrades = new Map();

        // Unlock Conditions System
        this.unlockConditions = new Map();

        // Event-System für Callbacks
        this.listeners = new Map();

        // Game Loop & Save Intervals
        this.gameLoopInterval = null;
        this.saveInterval = null;

        // Initialisierung
        this.init();
    }

    /**
     * Initialisiert das Spiel
     */
    init() {
        this.loadGame();
        this.calculateIdleProgress();
        this.startGameLoop();
        this.startAutoSave();
    }

    /**
     * Registriert einen Event Listener
     * @param {string} event - Event Name (z.B. 'pointsChanged', 'upgradeUnlocked')
     * @param {Function} callback - Callback-Funktion
     */
    on(event, callback) {
        if (!this.listeners.has(event)) {
            this.listeners.set(event, []);
        }
        this.listeners.get(event).push(callback);
    }

    /**
     * Triggert ein Event
     * @param {string} event - Event Name
     * @param {*} data - Event Daten
     */
    emit(event, data) {
        if (this.listeners.has(event)) {
            this.listeners.get(event).forEach(callback => callback(data));
        }
    }

    /**
     * Führt einen Click aus
     * @returns {number} Anzahl der erhaltenen Punkte
     */
    click() {
        const points = this.state.clickPower;
        this.addPoints(points);
        this.state.totalClicks++;
        this.emit('click', { points, totalClicks: this.state.totalClicks });
        this.checkUnlocks();
        return points;
    }

    /**
     * Fügt Punkte hinzu
     * @param {number} amount - Anzahl der Punkte
     */
    addPoints(amount) {
        this.state.points += amount;
        this.state.totalPointsEarned += amount;
        this.emit('pointsChanged', this.state.points);
        this.checkUnlocks();
    }

    /**
     * Entfernt Punkte (für Käufe)
     * @param {number} amount - Anzahl der Punkte
     * @returns {boolean} True wenn erfolgreich
     */
    spendPoints(amount) {
        if (this.state.points >= amount) {
            this.state.points -= amount;
            this.emit('pointsChanged', this.state.points);
            return true;
        }
        return false;
    }

    /**
     * Registriert ein neues Upgrade
     * @param {Object} upgradeConfig - Upgrade-Konfiguration
     * @returns {Upgrade} Das erstellte Upgrade
     */
    registerUpgrade(upgradeConfig) {
        const upgrade = new Upgrade(upgradeConfig, this);
        this.upgrades.set(upgrade.id, upgrade);
        this.emit('upgradeRegistered', upgrade);
        return upgrade;
    }

    /**
     * Kauft ein Upgrade
     * @param {string} upgradeId - ID des Upgrades
     * @returns {boolean} True wenn erfolgreich
     */
    buyUpgrade(upgradeId) {
        const upgrade = this.upgrades.get(upgradeId);
        if (!upgrade) return false;

        // Check if upgrade is unlocked
        if (!upgrade.isUnlocked()) return false;

        const cost = upgrade.getCurrentCost();

        if (this.state.points >= cost) {
            if (this.spendPoints(cost)) {
                upgrade.purchase();
                this.recalculateStats();
                this.emit('upgradePurchased', upgrade);
                this.checkUnlocks();
                return true;
            }
        }
        return false;
    }

    /**
     * Berechnet alle Spielstats neu (z.B. nach Upgrade-Kauf)
     */
    recalculateStats() {
        // Reset Stats
        this.state.clickPower = 1;
        this.state.pointsPerSecond = 0;

        // Summiere alle Upgrade-Effekte
        this.upgrades.forEach(upgrade => {
            if (upgrade.level > 0) {
                upgrade.applyEffect(this.state);
            }
        });

        this.emit('statsChanged', this.state);
    }

    /**
     * Game Loop - wird jedes Tick aufgerufen
     */
    gameTick() {
        const now = Date.now();
        const deltaTime = (now - this.state.lastTick) / 1000; // in Sekunden

        // Idle-Produktion
        if (this.state.pointsPerSecond > 0) {
            const idlePoints = this.state.pointsPerSecond * deltaTime;
            this.addPoints(idlePoints);
        }

        this.state.lastTick = now;
        this.emit('tick', { deltaTime });
    }

    /**
     * Startet den Game Loop
     */
    startGameLoop() {
        if (this.gameLoopInterval) {
            clearInterval(this.gameLoopInterval);
        }
        this.gameLoopInterval = setInterval(() => this.gameTick(), this.config.tickRate);
    }

    /**
     * Stoppt den Game Loop
     */
    stopGameLoop() {
        if (this.gameLoopInterval) {
            clearInterval(this.gameLoopInterval);
            this.gameLoopInterval = null;
        }
    }

    /**
     * Startet Auto-Save
     */
    startAutoSave() {
        if (this.saveInterval) {
            clearInterval(this.saveInterval);
        }
        this.saveInterval = setInterval(() => this.saveGame(), this.config.saveInterval);
    }

    /**
     * Berechnet Idle Progress (Offline-Produktion)
     */
    calculateIdleProgress() {
        const now = Date.now();
        const offlineTime = (now - this.state.lastTick) / 1000; // in Sekunden

        if (offlineTime > 1 && this.state.pointsPerSecond > 0) {
            // Maximale Offline-Zeit: 24 Stunden
            const maxOfflineTime = 24 * 60 * 60;
            const actualOfflineTime = Math.min(offlineTime, maxOfflineTime);

            const offlinePoints = this.state.pointsPerSecond * actualOfflineTime;
            this.addPoints(offlinePoints);

            this.emit('idleProgress', {
                offlineTime: actualOfflineTime,
                pointsEarned: offlinePoints
            });
        }

        this.state.lastTick = now;
    }

    /**
     * Speichert das Spiel in LocalStorage
     */
    saveGame() {
        const saveData = {
            state: this.state,
            upgrades: {}
        };

        // Speichere Upgrade-Levels und unlock status
        this.upgrades.forEach((upgrade, id) => {
            saveData.upgrades[id] = {
                level: upgrade.level,
                unlocked: upgrade.unlocked
            };
        });

        try {
            localStorage.setItem(this.config.saveKey, JSON.stringify(saveData));
            this.emit('gameSaved', saveData);
        } catch (error) {
            console.error('Fehler beim Speichern:', error);
            this.emit('saveError', error);
        }
    }

    /**
     * Lädt das Spiel aus LocalStorage
     */
    loadGame() {
        try {
            const savedData = localStorage.getItem(this.config.saveKey);
            if (savedData) {
                const data = JSON.parse(savedData);

                // Lade State
                if (data.state) {
                    Object.assign(this.state, data.state);
                }

                // Upgrades werden später geladen (nach Registrierung)
                this.savedUpgrades = data.upgrades || {};

                this.emit('gameLoaded', data);
                return true;
            }
        } catch (error) {
            console.error('Fehler beim Laden:', error);
            this.emit('loadError', error);
        }
        return false;
    }

    /**
     * Lädt gespeicherte Upgrade-Levels
     */
    loadUpgradeLevels() {
        if (this.savedUpgrades) {
            Object.entries(this.savedUpgrades).forEach(([id, data]) => {
                const upgrade = this.upgrades.get(id);
                if (upgrade) {
                    // Support old save format (just level number) and new format (object)
                    if (typeof data === 'number') {
                        upgrade.level = data;
                    } else {
                        upgrade.level = data.level || 0;
                        upgrade.unlocked = data.unlocked !== undefined ? data.unlocked : upgrade.unlocked;
                    }
                }
            });
            this.recalculateStats();
            this.checkUnlocks();
        }
    }

    /**
     * Resettet das Spiel
     */
    reset() {
        this.stopGameLoop();

        // Reset State
        this.state = {
            points: 0,
            totalClicks: 0,
            totalPointsEarned: 0,
            clickPower: 1,
            pointsPerSecond: 0,
            lastTick: Date.now(),
            startTime: Date.now()
        };

        // Reset Upgrades
        this.upgrades.forEach(upgrade => {
            upgrade.level = 0;
            // Reset unlock status (but respect if there's no unlock condition)
            upgrade.unlocked = upgrade.unlockCondition ? false : true;
        });

        // Lösche Save
        localStorage.removeItem(this.config.saveKey);

        this.recalculateStats();
        this.startGameLoop();
        this.emit('gameReset');
    }

    /**
     * Prüft und aktualisiert alle Unlock-Bedingungen
     */
    checkUnlocks() {
        this.upgrades.forEach(upgrade => {
            if (!upgrade.unlocked && upgrade.checkUnlockCondition()) {
                upgrade.unlock();
                this.emit('upgradeUnlocked', upgrade);
            }
        });
    }

    /**
     * Gibt die aktuellen Spielstats zurück
     * @returns {Object} Spielstats
     */
    getStats() {
        return {
            ...this.state,
            upgradeCount: this.upgrades.size,
            playTime: Date.now() - this.state.startTime
        };
    }

    /**
     * Gibt die Anzahl der gekauften Upgrades für ein bestimmtes Upgrade zurück
     * @param {string} upgradeId - ID des Upgrades
     * @returns {number} Level des Upgrades
     */
    getUpgradeLevel(upgradeId) {
        const upgrade = this.upgrades.get(upgradeId);
        return upgrade ? upgrade.level : 0;
    }
}

/**
 * Upgrade-Klasse
 * Repräsentiert ein einzelnes Upgrade im Spiel
 */
class Upgrade {
    /**
     * Erstellt ein neues Upgrade
     * @param {Object} config - Upgrade-Konfiguration
     * @param {IdleGame} game - Referenz zum Spiel
     */
    constructor(config, game) {
        this.id = config.id;
        this.name = config.name;
        this.description = config.description;
        this.baseCost = config.baseCost;
        this.costMultiplier = config.costMultiplier || 1.15;
        this.level = 0;
        this.maxLevel = config.maxLevel || Infinity;
        this.effect = config.effect; // Funktion die den Effekt anwendet
        this.game = game;

        // Unlock System
        this.unlockCondition = config.unlockCondition || null; // Funktion die prüft ob freigeschaltet
        this.unlockDescription = config.unlockDescription || null; // Text der die Bedingung beschreibt
        this.unlocked = config.unlockCondition ? false : true; // Standardmäßig unlocked wenn keine Bedingung
    }

    /**
     * Berechnet die aktuellen Kosten
     * @returns {number} Kosten für nächstes Level
     */
    getCurrentCost() {
        return Math.floor(this.baseCost * Math.pow(this.costMultiplier, this.level));
    }

    /**
     * Kauft das Upgrade (erhöht Level)
     */
    purchase() {
        if (this.level < this.maxLevel) {
            this.level++;
        }
    }

    /**
     * Wendet den Upgrade-Effekt auf den Spielzustand an
     * @param {Object} state - Spielzustand
     */
    applyEffect(state) {
        if (this.effect) {
            this.effect(state, this.level);
        }
    }

    /**
     * Prüft ob das Upgrade verfügbar ist
     * @param {number} currentPoints - Aktuelle Punkte
     * @returns {boolean} True wenn kaufbar
     */
    canAfford(currentPoints) {
        return this.unlocked && currentPoints >= this.getCurrentCost() && this.level < this.maxLevel;
    }

    /**
     * Prüft ob die Unlock-Bedingung erfüllt ist
     * @returns {boolean} True wenn die Bedingung erfüllt ist
     */
    checkUnlockCondition() {
        if (!this.unlockCondition) return true;
        return this.unlockCondition(this.game);
    }

    /**
     * Schaltet das Upgrade frei
     */
    unlock() {
        this.unlocked = true;
    }

    /**
     * Prüft ob das Upgrade freigeschaltet ist
     * @returns {boolean} True wenn freigeschaltet
     */
    isUnlocked() {
        return this.unlocked;
    }

    /**
     * Gibt Upgrade-Info zurück
     * @returns {Object} Upgrade-Informationen
     */
    getInfo() {
        return {
            id: this.id,
            name: this.name,
            description: this.description,
            level: this.level,
            maxLevel: this.maxLevel,
            currentCost: this.getCurrentCost(),
            nextCost: this.level < this.maxLevel ?
                Math.floor(this.baseCost * Math.pow(this.costMultiplier, this.level + 1)) :
                null,
            unlocked: this.unlocked,
            unlockDescription: this.unlockDescription
        };
    }
}
